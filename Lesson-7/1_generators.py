# Генераторы
# Функции генераторов (их описание можно почитать в PEP 255) представляют собой особый вид функций,
# которые возвращают «ленивый итератор». И хотя содержимое этих объектов вы можете перебирать также как и списки,
# но при этом, в отличие от списков, ленивые итераторы не хранят свое содержимое в памяти.

# Пример бесконечной последовательности
def infinite_sequence():
    num = 0
    while True:
        # if num == 100:
        #     break
        yield num
        num += 1


for i in infinite_sequence():
    print(i)


# Нахождение палиндромов
# можно использовать бесконечные последовательности множеством различных способов.
# Одним из них, является создание детектора палиндромов.
# Детектор палиндромов выявляет все последовательности букв и цифр, которые являются палиндромами.
# Это слова или числа, которые читаются одинаково вперед и назад, как «121» например.
# Сперва зададим наш числовой детектор палиндромов:
def is_palindrome(num):
    # Skip single-digit inputs
    if num // 10 == 0:
        return False
    temp = num
    reversed_num = 0
    while temp != 0:
        reversed_num = (reversed_num * 10) + (temp % 10)
        temp = temp // 10
    if num == reversed_num:
        return num
    else:
        return False


for num in infinite_sequence():
    pal = is_palindrome(num)
    if pal:
        print(pal)


# Не особо беспокойтесь о понимании вычислений, лежащих в основе данного кода.
# Просто заметьте, что функция принимает введенное число, переворачивает его, и сравнивает с оригиналом.
# Теперь вы можете использовать генератор бесконечной последовательности
# для получения бегущего списка со всеми числовыми палиндромами
# В консоли выводятся только те номера, которые читаются одинаково и вперед и назад.
#
# Примечание: на практике вам вряд ли придется писать свой собственный бесконечный генератор последовательностей,
# по той простой причине, что есть уже очень эффективный генератор itertools.count() из модуля itertools.

# Понимание работы генератора Python
# К этому моменту вы уже познакомились с двумя основными способами создания генераторов:
# с помощью функции и с помощью выражения. У вас также должно было сформироваться интуитивное представление о том,
# как работает генератор. Давайте теперь уделим некоторое время тому, чтобы сделать наши знания более четкими.
#
# Функции генераторов выглядят и действуют как обычные функции, но с одной определяющей особенностью.
# А именно, функция генератора используют ключевое слово yield вместо return.
# Давайте вспомним функцию генератора, которую написали ранее:
def infinite_sequence():
    num = 0
    while True:
        yield num
        num += 1


# Это похоже на типичное определение функции, за исключением yield и кода, который следует за ним.
# Ключевое слово yield применяется там, где значение нужно отправить обратно вызывающей стороне.
# Но в отличие от return, выхода из функции в данном случае не происходит.
# Вместо этого, при возврате состояние функции запоминается.
# Более того, когда next() вызывается для объекта-генератора (явно или неявно в цикле for),
# ранее полученная переменная num увеличивается, а затем возвращается снова.
# Поскольку функции генератора похожи на другие функции и действуют подобным образом, вы можете предположить,
# что выражения создающие генераторы очень похожи на другие выражениях в Python создающие объекты.

# Создание генератора с помощью выражения
# Как и выражения создающие списки, выражения создающие генераторы позволяют быстро получить объект генератора с
# помощью всего одной строчки кода. Использоваться они могут в тех же случаях, что и выражения создающие списки,
# но при этом у них есть одно дополнительное преимущество. Их можно создавать не удерживая весь объект в памяти
# перед итерацией. Если перефразировать, вы не будете расходовать память при использовании генератора.
#
# Давайте для примера возьмем возведение в квадрат некоторых чисел:


nums_squared_lc = [num ** 2 for num in range(5)]
nums_squared_gc = (num ** 2 for num in range(5))

# И nums_squared_lc, и nums_squared_gc выглядят практически одинаково, но есть одно ключевое отличие.
# Вы сможете его заметить? Для первого объекта использовались квадратные скобки и это привело к созданию списка.
# Для второго использовались круглые скобки, и это привело к созданию генератора. Посмотрите, что произойдет,
# если мы выведем содержание каждого из этих объектов:
#
# nums_squared_lc
# [0, 1, 4, 9, 16]
# nums_squared_gc
# <generator object <genexpr> at 0x107fbbc78>
# Это подтверждает тот факт, что с помощью круглых скобок вы создали объект генератора, а также то,
# что он отличается от списка.

# Списковые включения ... *advanced файлы


